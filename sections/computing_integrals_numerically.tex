%!TEX root = ../calculus_tutorial.tex


	\subsection{Computing integrals numerically}

		% There are numerous ways to compute integrals using Python.
		Computing integral of $f(x)$ ``numerically'' means
		we're splitting the region of integration into many (think thousands or millions) of strips,
		computing the areas of these strips,
		then adding up the areas to obtain the total area under the graph of $f(x)$.
		The approximation to the area under $f(x)$ between $x=a$ and $x=b$
		using $n$ rectangular strips corresponds to the following formula:
		\[
			A_f(a,b)
			\approx
			\sum_{k=1}^{n} f(a + k\Delta x)\,\Delta x,
		\]
		where $\Delta x = \frac{b-a}{n}$ is the width of the rectangular strips.
		The right endpoint of the $k$\textsuperscript{th}
		is located at $x_k = a + k\Delta x$,
		so the height of the rectangular strips $f(x_k)$
		varies as $k$ goes from between $k=1$ (first strip)
		and $k=n$ (last strip).

		Let's check that the formula $f(a + k\Delta x)\Delta x$
		correctly describes the area of the $k$\textsuperscript{th} rectangular strip.
		Since we're using choosing the height of the rectangles according to their right endpoints,
		the area of the first rectangle is $f(x_1)\Delta x = f(a + \Delta x)\Delta x$,
		which is the height of the function $f$ at $a+\Delta x$ times the width $\Delta x$.
		The second rectangle has height $f(a+2\Delta x)$,
		the third rectangle will have height $f(a+3\Delta x)$,
		and so on until the last one which has height $f(a+n\Delta x) = f(a+n\,\frac{b-a}{n} ) =  f(b)$.
		% we take a step of width $\Delta x$ to the right: $x_2 = x_1 + \Delta x = a + 2 \Delta x$.

		Instead of manually commuting all the $n$ area calculations in the summaiton,
		we can write Python code that takes an arbitrary function \tt{f} as input
		and performs the $n$-rectangle area approximation calculation for us:

		\begin{codeblock}[]
		>>> def integrate(f, a, b, n=10000):
		        """
		        Computes the area under the graph of `f`
		        between `x=a` and `x=b` using `n` rectangles.
		        """
		        dx = (b - a) / n
		        xs = [a + k*dx for k in range(1,n+1)]
		        fxs = [f(x) for x in xs]
		        area = sum([fx*dx for fx in fxs])
		        return area
		\end{codeblock}


		\noindent
		The code implements word-for-word the summation that we defined in the above equation.
		We first compute the width of the rectangles $\code{dx} = \Delta x$.
		We then create the list \tt{xs} that contains the $x$-coordinates of the right endpoints
		of the $\tt{xs} = [a + \Delta x, a + 2k\Delta x, a + 3k\Delta x, \ldots, b]$,
		and evaluate the function \tt{f} at these $x$-values
		to obtain $\tt{fxs} = [f(a + \Delta x), f(a + 2k\Delta x), f(a + 3k\Delta x), \ldots, f(b)]$.
		We obtain the total area
		by multiplying each \tt{fx} in \tt{fxs} by the width \tt{dx}
		and summing of them together.




		\subsubsection{Example 3 continued}
	
Let's use the \tt{integrate} procedure
to compute the integral of the function $h(x) = x^3 - 5x^22 + x + 10$
that we saw in Example~3.
First we define a Python function that implements $h$:

\begin{codeblock}[]
>>> def h(x):
        return x**3 - 5*x**2 + x + 10
\end{codeblock}

We can now calculate the $n=25$ approximation to the
area under the graph of $h(x)$ between $x=-1$ and $x=4$
as follows:

\begin{codeblock}[]
>>> integrate(h, -1, 4, n=25)
12.399999999999997
\end{codeblock}

\noindent
Then you can compute $S_{25}$ by calling \code{integrate(f, -1, 4, n=25)},
which returns $S_{25}=12.4$.


Calling \code{integrate(f, -1, 4, 50)} you'll obtain $S_{50}=12.6625$.

\begin{codeblock}[]
>>> integrate(h, -1, 4, n=50)
12.6625
\end{codeblock}



\begin{figure}[htb]
	\centering
	\subfigure[$n=25$]{				
		\includegraphics[width=0.45\columnwidth]{figures/calculus/riemannsum-25.png}
	}
	\subfigure[$n=50$]{				
		\includegraphics[width=0.45\columnwidth]{figures/calculus/riemannsum-50.png}
	}
	\vspace{-2mm}
	\caption{An approximation to the area under the graph of the function $f(x)=x^3-5x^2+x+10$ 
			using $n=25$ and $n=50$ rectangles.}
	\label{fig:riemannsum-25-50}
\end{figure}



The approximations will get better and better
if we increase the number of rectangles $n$.
For $n=100$,
the sum of the rectangles' areas is $S_{100} =  12.7906$,
for $n=1000$ the approximation gives us $S_{1000} = 12.9041562$,
which is accurate to the first decimal.

\begin{codeblock}[]
>>> integrate(h, -1, 4, n=1000)
12.90415625
>>> integrate(h, -1, 4, n=100000)
12.916654166656249
\end{codeblock}
	
	
The exact value of the area $A_h(-1,4)$ is $\frac{155}{12} = 12.91\overline{6}$.
We'll see how to compute this in the next section,
when we learn about symbolic integration,
which is a math ``shortcut'' that allows us compute exact integral for certain functions.
For now,
we content ourselves with numerical approximations,
which are pretty good already.
The approximation with $n = 100K$ is accurate to four decimals!


		\subsubsection{Examples 1 and 2 revisited}
		
			We can also use \tt{integrate} to compute the integral of a constant function $f(x)=3$
			and the linear function $g(x)=x$ that computed geometrically earlier.

			\begin{codeblock}[]
			>>> def f(x):
			        return 3
			>>> integrate(f, a=0, b=5, n=100000)
			15.000000000000002
			>>> def g(x):
			        return x
			>>> integrate(g, a=0, b=5, n=100000)
			12.500125
			\end{codeblock}

			\noindent
			The numerical approximations we obtain are very close
			to the exact answers $\int_0^5 f(x)\,dx = 3\cdot 5 = 15$
			and $\int_0^5 g(x) \, dx = \tfrac{1}{2} 5 \cdot 5 = 12.5$.
			


%We can approximate the total area under the function $f(x)$ between $x=a$ and $x=b$ by splitting the region into $n$ tiny vertical strips of width $\Delta x$,
%then adding up the areas of the rectangular strips.
%This is known as a \emph{Riemann sum} approximation for an area.
%Figure~\ref{fig:riemannsum-25-50} shows the Riemann sum approximations for the area under the function
%$f(x)=x^3-5x^2+x+10$ between $x=-1$ and $x=4$,
%obtained by using $n=25$ and $n=50$ vertical rectangular strips.
%		it would take you forever.
%		Computing an approximation with $n=1000$ rectangles requires computing $1000$ rectangle areas
%		and the sum of $1000$ terms!










	\subsection{Formal definition of integral}

% TODO: wrap in shadethrm

		In the limit as the number of rectangles $n$ approaches $\infty$, 							\index{infinity}
		the approximation to the area under the curve becomes \emph{arbitrarily close} to the true area.
		The notion of applying the a rectangular-strip approximation to the area of a function,
		where the number of rectangles grows to infinity is known as the \emph{Riemann sum}
		and is the basis for the definitions of the integral:

		The integral between $x=a$ and $x=b$ is \emph{defined}
		as the limit as $n$ goes to infinity:
		\[
			\int_{a}^{b}\!f(x)\:dx 
				\equiv \lim_{n\to\infty} \sum_{k=1}^{n} f(a + k\Delta x)\Delta x \equiv A(a,b).
		\]
		This is sometimes called the \emph{Riemann sum} formula.







	\subsection{Computing integrals numerically using SciPy}
	
		The Python function \tt{quad} in the module \tt{scipy.integrate} allows us to compute the integral of any function.
		The name \tt{quad} is short for ``quadrature'' which is the historical math term used for find-the-area procedures.
		Let's start by importing the \tt{quad} function.
	
		\begin{codeblock}[import-quad-from-scipy]

		\end{codeblock}
	
	
		To compute the integral $\int_0^5 f(x) dx$ we call the function \tt{quad}
		with inputs \tt{f} as the first argument,
		and the limits of integration $a=0$ and $b=5$ as the second and third arguments.
	
		\begin{codeblock}[quad-f-0-5-tuple]
		>>> from scipy.integrate import quad
		>>> quad(f, 0, 5)
		(15.0, 1.1102230246251565e-13)
		\end{codeblock}
	
		\noindent
		The function \tt{quad} returns a tuple (a pair of numbers) as output: $(A,\epsilon)$.
		The first number in the tuple is the value of the area calculation.
		The second number $\epsilon$ tells us the accuracy of the procedure used to calculate the area.
		In the above calculation,
		the output tells us the integral $\int_0^5 f(x) dx$ is equal to $15.0$ up to a precision on the order of $10^{-13}$.
	
		Since we're usually only interested in the value of the area $A$ and not the precision $\epsilon$,
		we often select the first number in the output of \tt{quad}.
		This is why you'll often see the expression \tt{quad(...)[0]} in code examples.
	
		\begin{codeblock}[quad-f-0-5]
		>>> quad(f, 0, 5)[0]  # extract the value A_f(0,5)
		15.0
		\end{codeblock}

		\noindent
		As a second example,
		let's calculate the area under the graph of the function $g(x)=x$ between $x=0$ and $x=5$.
	
		\begin{codeblock}[deffun-g-eq-x-and-quad-g-0-5]
		>>> def g(x):
		        return x
		>>> quad(g, 0, 5)[0]
		12.5
		\end{codeblock}
	
		\noindent
		The answer we obtained matches the results of the general formula we obtained above,
		$A_g(0,5) = \frac{1}{2}b^2$,
		when the upper limit of integration is $b=5$.

		The main takeaway message is that the \tt{quad} function is your friend whenever you need to compute integrals.
		All the scary-looking math equations that contain the $\int$ symbol can be computed using one or two lines of Python code.
		


TODO h
\begin{codeblock}[quad-h-minus1-4]
>>> quad(h, 0, 5)[0]  # extract A
10.416666666666675
\end{codeblock}

	


		\ifthenelse{\boolean{FORSTATSBOOK}}{	
			We'll use the function \tt{quad} hundreds of times in the remainder of the book to compute various integrals
			as part of probability and statistics calculations,
			so make sure you understand what is going on in the above code examples.
		}{}
